{"version":3,"sources":["../src/server.ts","../src/routes/checkAddress.ts","../src/services/blockchair.ts","../src/services/riskAnalyzer.ts","../src/utils/addressValidator.ts","../src/services/blockchainApis.ts","../src/services/priceAPI.ts","../src/middleware/security.ts"],"sourcesContent":["import express, { Express } from 'express'\nimport checkAddressRoutes from './routes/checkAddress'\nimport { corsHeaders, rateLimiter, validateRequest, securityHeaders } from './middleware/security'\nimport { initializePriceCache } from './services/priceAPI'\n\nconst app: Express = express()\nconst PORT = process.env.PORT || 3001\n\n// CORS middleware FIRST (before other middleware)\napp.use(corsHeaders)\n\n// JSON body parser BEFORE routes\napp.use(express.json({ limit: '10kb' }))\n\n// Security middleware\napp.use(rateLimiter)\napp.use(validateRequest)\napp.use(securityHeaders)\n\n// API Routes\napp.use('/api', checkAddressRoutes)\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.status(200).json({\n    status: 'OK',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n    version: '1.0.0',\n  })\n})\n\n// 404 handler for undefined routes\napp.use((req, res) => {\n  res.status(404).json({\n    success: false,\n    error: 'Endpoint not found',\n    code: 'NOT_FOUND',\n  })\n})\n\n// Global error handler\napp.use((err: unknown, req: express.Request, res: express.Response) => {\n  console.error('Unhandled error:', {\n    error: err instanceof Error ? err.message : 'Unknown error',\n    stack: err instanceof Error ? err.stack : undefined,\n    url: req.url,\n    method: req.method,\n    timestamp: new Date().toISOString(),\n  })\n\n  res.status(500).json({\n    success: false,\n    error: 'Internal server error',\n    code: 'INTERNAL_ERROR',\n  })\n})\n\n// Start server\napp.listen(PORT, async () => {\n  console.error('ðŸš€ Crypto Guardian API server running on port', PORT)\n  console.error('ðŸ“Š Health check: http://localhost:', `${PORT}/health`)\n  console.error('ðŸ” API endpoint: http://localhost:', `${PORT}/api/check-address`)\n\n  // Initialize price cache\n  try {\n    await initializePriceCache()\n    console.error('ðŸ’° Price cache initialized successfully')\n  } catch (error) {\n    console.error('âš ï¸ Failed to initialize price cache:', error)\n  }\n})\n\nexport default app\n","import { Router, type Request, type Response, type Router as RouterType } from 'express'\nimport { checkAddress } from '../services/blockchair'\nimport { validateAddress } from '../utils/addressValidator'\nimport type { AddressCheckResponse } from '../types'\n\nconst router: RouterType = Router()\n\n// POST /api/check-address\nrouter.post('/check-address', async (req: Request, res: Response) => {\n  try {\n    const { address } = req.body\n\n    // Validate request body\n    if (!address) {\n      return res.status(400).json({\n        success: false,\n        error: 'Address is required',\n        code: 'MISSING_ADDRESS',\n      } as AddressCheckResponse)\n    }\n\n    // Basic input validation\n    if (typeof address !== 'string') {\n      return res.status(400).json({\n        success: false,\n        error: 'Address must be a string',\n        code: 'INVALID_TYPE',\n      } as AddressCheckResponse)\n    }\n\n    if (address.trim().length < 5) {\n      return res.status(400).json({\n        success: false,\n        error: 'Address too short',\n        code: 'ADDRESS_TOO_SHORT',\n      } as AddressCheckResponse)\n    }\n\n    // Validate address format\n    const validation = validateAddress(address.trim())\n    if (!validation.isValid) {\n      return res.status(400).json({\n        success: false,\n        error:\n          'Invalid address format. Supported: Ethereum (0x...), Bitcoin (1..., bc1...), BSC, Polygon, Arbitrum',\n        code: 'INVALID_ADDRESS_FORMAT',\n      } as AddressCheckResponse)\n    }\n\n    // Check address\n    const result = await checkAddress(address.trim())\n\n    res.json({\n      success: true,\n      data: result,\n    } as AddressCheckResponse)\n  } catch (error: unknown) {\n    console.error('Error in /check-address route:', {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      code: (error as { code?: string })?.code,\n      address: req.body?.address,\n      timestamp: new Date().toISOString(),\n    })\n\n    // Handle specific error types\n    if ((error as { code?: string })?.code === 'ADDRESS_NOT_FOUND') {\n      return res.status(404).json({\n        success: false,\n        error: 'Address not found on blockchain',\n        code: 'ADDRESS_NOT_FOUND',\n      } as AddressCheckResponse)\n    }\n\n    if ((error as { code?: string })?.code === 'RATE_LIMIT') {\n      return res.status(429).json({\n        success: false,\n        error: 'Too many requests. Please try again later.',\n        code: 'RATE_LIMIT',\n      } as AddressCheckResponse)\n    }\n\n    if ((error as { code?: string })?.code === 'INVALID_ADDRESS') {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid address format',\n        code: 'INVALID_ADDRESS',\n      } as AddressCheckResponse)\n    }\n\n    // Generic server error\n    res.status(500).json({\n      success: false,\n      error: 'Internal server error. Please try again later.',\n      code: 'INTERNAL_ERROR',\n    } as AddressCheckResponse)\n  }\n})\n\n// GET /api/supported-chains\nrouter.get('/supported-chains', (req: Request, res: Response) => {\n  res.json({\n    success: true,\n    data: {\n      chains: [\n        { name: 'Ethereum', symbol: 'ETH', pattern: '0x...' },\n        { name: 'Bitcoin', symbol: 'BTC', pattern: '1..., bc1...' },\n        { name: 'Binance Smart Chain', symbol: 'BSC', pattern: '0x...' },\n        { name: 'Polygon', symbol: 'MATIC', pattern: '0x...' },\n        { name: 'Arbitrum', symbol: 'ARB', pattern: '0x...' },\n      ],\n    },\n  })\n})\n\nexport default router\n","import NodeCache from 'node-cache'\nimport { RiskAnalyzer } from './riskAnalyzer'\nimport { validateAddress } from '../utils/addressValidator'\nimport { getAddressData } from './blockchainApis'\nimport type { BlockchainType } from '../types'\n\n// Cache setup\nconst cache = new NodeCache({ stdTTL: 300 }) // 5 minutes\n\n// Get address info from multiple APIs\nexport const getAddressInfo = async (address: string, blockchain: BlockchainType) => {\n  const cacheKey = `${blockchain}-${address}`\n\n  // Check cache first\n  const cachedData = cache.get(cacheKey)\n  if (cachedData) {\n    return cachedData\n  }\n\n  try {\n    const addressData = await getAddressData(address, blockchain)\n\n    // Cache the result\n    cache.set(cacheKey, addressData)\n\n    return addressData\n  } catch (error: unknown) {\n    console.error('Error fetching address info:', {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      address,\n      blockchain,\n    })\n\n    throw new Error(error instanceof Error ? error.message : 'Unknown error')\n  }\n}\n\n// Get recent transactions (simplified - not implementing for all APIs)\nexport const getRecentTransactions = async (_address: string, _blockchain: BlockchainType) => {\n  // For now, return empty transactions since we're focusing on basic address validation\n  // Could be extended later with specific API implementations\n  return []\n}\n\n// Main check address function\nexport const checkAddress = async (address: string) => {\n  try {\n    // Validate address format and detect blockchain\n    const validation = validateAddress(address)\n\n    if (!validation.isValid) {\n      throw new Error('Invalid address format')\n    }\n\n    const normalizedAddress = validation.normalizedAddress || address\n    const blockchain = validation.blockchain\n\n    // Get address info\n    const addressData = ((await getAddressInfo(normalizedAddress, blockchain)) as {\n      transaction_count?: number\n      balance?: string\n      total_value?: string\n    }) || {\n      transaction_count: 0,\n      balance: '0',\n      total_value: '0',\n    }\n\n    // Get transactions\n    const transactions = await getRecentTransactions(normalizedAddress, blockchain)\n\n    // Analyze with risk analyzer\n    const riskAnalyzer = new RiskAnalyzer()\n    const analysis = riskAnalyzer.analyze(\n      {\n        transaction_count: addressData?.transaction_count || 0,\n        balance: addressData?.balance || '0',\n      },\n      transactions\n    )\n\n    // Update analysis with address and blockchain info\n    // Ensure we use the calculated USD value from blockchainApis, not the default from riskAnalyzer\n    return {\n      ...analysis,\n      address: normalizedAddress,\n      blockchain,\n      total_value: addressData?.total_value || analysis.total_value,\n    }\n  } catch (error: unknown) {\n    console.error('Error checking address:', {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      address,\n    })\n\n    // Fallback to local analysis only\n    const validation = validateAddress(address)\n    const riskAnalyzer = new RiskAnalyzer()\n\n    // Create minimal data structure for local analysis\n    const minimalData = {\n      address: validation.normalizedAddress || address,\n      balance: '0',\n      transaction_count: 0,\n    }\n\n    const localAnalysis = riskAnalyzer.analyze(minimalData, [])\n\n    return {\n      address: validation.normalizedAddress || address,\n      verdict: localAnalysis.verdict || 'CLEAN',\n      risk_score: Math.max(localAnalysis.risk_score || 0, 15), // Min 15 score for unknown\n      findings: [\n        'Using multiple free APIs with limited data',\n        ...localAnalysis.findings.slice(0, 3), // Include local findings\n      ],\n      transaction_count: 0,\n      total_value: '0',\n      recommendation: 'Basic validation completed - verify independently if concerned',\n      blockchain: validation.blockchain,\n      balance: '0',\n    }\n  }\n}\n","import type { AddressData } from '../types'\n\ninterface Transaction {\n  value: string\n  time: string\n  sender?: string\n  recipient?: string\n  fee?: string\n}\n\ninterface AddressInfo {\n  transaction_count: number\n  balance?: string\n  received_usd?: string\n  first_seen?: string\n  last_seen?: string\n}\n\nexport class RiskAnalyzer {\n  // Blacklist of known scam patterns (can be expanded)\n  private readonly SCAM_PATTERNS = [\n    / Elon/i,\n    /muskrat/i,\n    /giveaway/i,\n    /double/i,\n    /airdrop/i,\n    /bonus/i,\n  ]\n\n  // Suspicious transaction patterns\n  private readonly analyzeTransactionPattern = (transactions: Transaction[]): number => {\n    let riskScore = 0\n    const txCount = transactions.length\n\n    if (txCount === 0) return riskScore\n\n    // 1. Zero-value transactions (often used for dust attacks)\n    const zeroValueTxs = transactions.filter(\n      tx => parseFloat(tx.value) === 0 || tx.value === '0'\n    ).length\n\n    if (zeroValueTxs > 20) {\n      riskScore += 30\n    } else if (zeroValueTxs > 10) {\n      riskScore += 20\n    } else if (zeroValueTxs > 5) {\n      riskScore += 10\n    }\n\n    // 2. High-frequency transactions (bot-like behavior)\n    if (txCount > 100) {\n      const txTimes = transactions.slice(0, 50).map(tx => new Date(tx.time).getTime())\n      if (txTimes.length > 1) {\n        const timeSpan = Math.max(...txTimes) - Math.min(...txTimes)\n        const timeHours = timeSpan / (1000 * 60 * 60)\n\n        if (timeHours < 1) {\n          riskScore += 40\n        } else if (timeHours < 24) {\n          riskScore += 25\n        }\n      }\n    }\n\n    // 3. Round number transactions (potential automation)\n    const roundNumbers = transactions.filter(tx => {\n      const value = parseFloat(tx.value)\n      return value > 0 && value % 1 === 0 && value < 1000\n    }).length\n\n    const roundPercentage = (roundNumbers / txCount) * 100\n    if (roundPercentage > 80) {\n      riskScore += 20\n    } else if (roundPercentage > 60) {\n      riskScore += 15\n    }\n\n    // 4. Large transactions relative to average\n    const values = transactions.map(tx => parseFloat(tx.value) || 0).filter(v => v > 0)\n\n    if (values.length > 10) {\n      const avgValue = values.reduce((a, b) => a + b, 0) / values.length\n      const largeTxs = values.filter(v => v > avgValue * 10).length\n\n      if (largeTxs > 0) {\n        riskScore += 15\n      }\n    }\n\n    return Math.min(riskScore, 100)\n  }\n\n  // Analyze address age and activity patterns\n  private readonly analyzeAddressAge = (\n    addressInfo: AddressInfo\n  ): { score: number; finding: string } => {\n    let score = 0\n    let finding = ''\n\n    const txCount = addressInfo.transaction_count || 0\n\n    // Very new address with high activity\n    if (txCount > 100) {\n      // If we had first_seen data, we could check age\n      // For now, just check transaction count\n      if (txCount > 1000) {\n        score = 25\n        finding = 'Unusually high activity for address'\n      } else if (txCount > 500) {\n        score = 15\n        finding = 'High transaction volume detected'\n      }\n    }\n\n    // Empty address with recent activity\n    const balance = parseFloat(addressInfo.balance || '0')\n    if (balance === 0 && txCount > 50) {\n      score = 20\n      finding = 'Address frequently emptied (potential mixer)'\n    }\n\n    return { score, finding }\n  }\n\n  // Analyze value patterns\n  private readonly analyzeValuePatterns = (\n    addressInfo: AddressInfo\n  ): { score: number; finding: string } => {\n    let score = 0\n    let finding = ''\n\n    const totalValue = parseFloat(addressInfo.received_usd || '0')\n\n    // Very high value\n    if (totalValue > 1000000) {\n      score = 10\n      finding = 'High value address (whale activity)'\n    }\n\n    return { score, finding }\n  }\n\n  // Main analysis function\n  public analyze = (addressInfo: AddressInfo, transactions: Transaction[]): AddressData => {\n    const findings: string[] = []\n    let totalRiskScore = 0\n\n    // Transaction pattern analysis\n    const txScore = this.analyzeTransactionPattern(transactions)\n    if (txScore > 0) {\n      totalRiskScore += txScore\n\n      if (txScore > 50) {\n        findings.push('Highly suspicious transaction patterns detected')\n      } else if (txScore > 30) {\n        findings.push('Unusual transaction activity')\n      } else {\n        findings.push('Some unusual transaction patterns')\n      }\n    }\n\n    // Address age analysis\n    const ageAnalysis = this.analyzeAddressAge(addressInfo)\n    if (ageAnalysis.score > 0) {\n      totalRiskScore += ageAnalysis.score\n      findings.push(ageAnalysis.finding)\n    }\n\n    // Value pattern analysis\n    const valueAnalysis = this.analyzeValuePatterns(addressInfo)\n    if (valueAnalysis.score > 0) {\n      totalRiskScore += valueAnalysis.score\n      findings.push(valueAnalysis.finding)\n    }\n\n    // Determine verdict based on total score\n    let verdict: 'CLEAN' | 'SUSPICIOUS' | 'MALICIOUS'\n    let recommendation: string\n\n    if (totalRiskScore >= 70) {\n      verdict = 'MALICIOUS'\n      recommendation = 'AVOID - This address shows highly suspicious activity patterns'\n    } else if (totalRiskScore >= 40) {\n      verdict = 'SUSPICIOUS'\n      recommendation = 'CAUTION - Exercise extreme care with this address'\n    } else if (totalRiskScore >= 20) {\n      verdict = 'SUSPICIOUS'\n      recommendation = 'PROCEED WITH CARE - Monitor transactions carefully'\n    } else {\n      verdict = 'CLEAN'\n      recommendation = 'SAFE - Address appears to be legitimate'\n    }\n\n    // If no findings, add default\n    if (findings.length === 0) {\n      findings.push('No suspicious activity detected')\n    }\n\n    return {\n      address: '', // Will be set by caller\n      verdict,\n      risk_score: Math.min(totalRiskScore, 100),\n      findings,\n      transaction_count: addressInfo.transaction_count || 0,\n      total_value: addressInfo.received_usd || '0',\n      recommendation,\n      blockchain: 'ethereum',\n      balance: addressInfo.balance || '0',\n    }\n  }\n}\n","import type { AddressValidationResult, BlockchainType } from '../types'\n\n// Ethereum address patterns\nconst ETHEREUM_PATTERN = /^0x[a-fA-F0-9]{40}$/i\n\n// Bitcoin address patterns\nconst BITCOIN_LEGACY = /^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/\nconst BITCOIN_SEGWIT = /^[bc1][a-hj-mnp-zAC-HJ-NP-Z0-9]{39,59}$/\nconst BITCOIN_TAPROOT = /^bc1p[ac-hj-np-z02-9]{58}$/\n\n// BSC address pattern (same as Ethereum)\nconst BSC_PATTERN = /^0x[a-fA-F0-9]{40}$/i\n\n// Polygon address pattern (same as Ethereum)\nconst POLYGON_PATTERN = /^0x[a-fA-F0-9]{40}$/i\n\n// Arbitrum address pattern (same as Ethereum)\nconst ARBITRUM_PATTERN = /^0x[a-fA-F0-9]{40}$/i\n\nexport const validateAddress = (address: string): AddressValidationResult => {\n  const trimmedAddress = address.trim()\n\n  // Ethereum and ENS (0x + 40 hex chars)\n  if (ETHEREUM_PATTERN.test(trimmedAddress)) {\n    return {\n      isValid: true,\n      blockchain: 'ethereum',\n      normalizedAddress: trimmedAddress.toLowerCase(),\n    }\n  }\n\n  // Bitcoin (legacy, segwit, taproot)\n  if (\n    BITCOIN_LEGACY.test(trimmedAddress) ||\n    BITCOIN_SEGWIT.test(trimmedAddress) ||\n    BITCOIN_TAPROOT.test(trimmedAddress)\n  ) {\n    return {\n      isValid: true,\n      blockchain: 'bitcoin',\n      normalizedAddress: trimmedAddress,\n    }\n  }\n\n  // BSC (Binance Smart Chain - same as Ethereum)\n  if (BSC_PATTERN.test(trimmedAddress)) {\n    return {\n      isValid: true,\n      blockchain: 'binance-smart-chain',\n      normalizedAddress: trimmedAddress.toLowerCase(),\n    }\n  }\n\n  // Polygon (same as Ethereum)\n  if (POLYGON_PATTERN.test(trimmedAddress)) {\n    return {\n      isValid: true,\n      blockchain: 'polygon',\n      normalizedAddress: trimmedAddress.toLowerCase(),\n    }\n  }\n\n  // Arbitrum (same as Ethereum)\n  if (ARBITRUM_PATTERN.test(trimmedAddress)) {\n    return {\n      isValid: true,\n      blockchain: 'arbitrum',\n      normalizedAddress: trimmedAddress.toLowerCase(),\n    }\n  }\n\n  return {\n    isValid: false,\n    blockchain: 'ethereum', // default\n  }\n}\n\nexport const getBlockchairBlockchain = (blockchain: BlockchainType): string => {\n  const mapping = {\n    ethereum: 'ethereum',\n    bitcoin: 'bitcoin',\n    'binance-smart-chain': 'binance-smart-chain',\n    polygon: 'polygon',\n    arbitrum: 'arbitrum',\n  }\n  return mapping[blockchain]\n}\n","import axios from 'axios'\nimport { setTimeout } from 'timers'\nimport { convertToUSD } from './priceAPI'\nimport type { BlockchainType } from '../types'\n\n// Common interface for all API providers\ninterface AddressData {\n  address: string\n  balance?: string\n  transaction_count?: number\n  total_value?: string\n  first_seen?: string\n  last_seen?: string\n}\n\n// Rate limiting\nconst RATE_LIMIT_DELAY = 500 // 500ms between requests\nconst lastRequestTimes = new Map<string, number>()\n\nconst rateLimit = (provider: string) => {\n  const now = Date.now()\n  const lastTime = lastRequestTimes.get(provider) || 0\n  const timeSinceLastRequest = now - lastTime\n\n  if (timeSinceLastRequest < RATE_LIMIT_DELAY) {\n    const delay = RATE_LIMIT_DELAY - timeSinceLastRequest\n    return new Promise(resolve => setTimeout(resolve, delay))\n  }\n\n  lastRequestTimes.set(provider, now)\n  return Promise.resolve()\n}\n\n// 1. Blockchain.com API (Free, generous limits) - Now also supports ETH via Etherscan\nexport const blockchainInfoAPI = async (\n  address: string,\n  blockchain: BlockchainType\n): Promise<AddressData | null> => {\n  await rateLimit('blockchain')\n\n  try {\n    if (blockchain === 'bitcoin') {\n      const response = await axios.get(`https://blockchain.info/q/address/${address}?format=json`, {\n        timeout: 10000,\n        headers: { 'User-Agent': 'Crypto-Guardian/1.0' },\n      })\n\n      const data = response.data\n      return {\n        address,\n        balance: data.final_balance?.toString() || '0',\n        transaction_count: data.n_tx || 0,\n      }\n    } else if (blockchain === 'ethereum') {\n      // Use a simple ETH balance API that doesn't require API key\n      const response = await axios.get(\n        `https://api.ethplorer.io/getAddressInfo/${address}?apiKey=freekey`,\n        {\n          timeout: 10000,\n          headers: { 'User-Agent': 'Crypto-Guardian/1.0' },\n        }\n      )\n\n      const data = response.data\n      return {\n        address,\n        balance: data.ETH?.balance || '0',\n        transaction_count: data.ETH?.txCount || 0,\n      }\n    }\n\n    return null\n  } catch (error) {\n    console.error(\n      'Blockchain.com API error:',\n      error instanceof Error ? error.message : 'Unknown error'\n    )\n    return null\n  }\n}\n\n// 2. Etherscan.io API (Free, 100k requests/day for Ethereum)\nexport const etherscanAPI = async (\n  address: string,\n  blockchain: BlockchainType\n): Promise<AddressData | null> => {\n  await rateLimit('etherscan')\n\n  try {\n    // Only supports Ethereum and EVM compatible chains\n    if (!['ethereum', 'binance-smart-chain', 'polygon', 'arbitrum'].includes(blockchain))\n      return null\n\n    const apiKeys = process.env.ETHERSCAN_API_KEY ? process.env.ETHERSCAN_API_KEY.split(',') : ['']\n\n    // Try different API keys if rate limited\n    for (const key of apiKeys) {\n      try {\n        const baseUrl =\n          blockchain === 'ethereum'\n            ? 'https://api.etherscan.io'\n            : blockchain === 'binance-smart-chain'\n              ? 'https://api.bscscan.com'\n              : blockchain === 'polygon'\n                ? 'https://api.polygonscan.com'\n                : 'https://api.arbiscan.io'\n\n        const response = await axios.get(`${baseUrl}/api`, {\n          params: {\n            module: 'account',\n            action: 'balance',\n            address,\n            tag: 'latest',\n            apikey: key || 'YourApiKeyToken',\n          },\n          timeout: 10000,\n          headers: {\n            'User-Agent': 'Crypto-Guardian/1.0',\n            Accept: 'application/json',\n          },\n        })\n\n        if (response.data.status === '1') {\n          return {\n            address,\n            balance: response.data.result || '0',\n          }\n        }\n      } catch {\n        continue // Try next API key\n      }\n    }\n\n    return null\n  } catch {\n    console.error('Etherscan API error')\n    return null\n  }\n}\n\n// 3. BlockCypher API (Free, 5 requests/second)\nexport const blockCypherAPI = async (\n  address: string,\n  blockchain: BlockchainType\n): Promise<AddressData | null> => {\n  await rateLimit('blockcypher')\n\n  try {\n    // Only support Bitcoin and Ethereum on BlockCypher\n    if (blockchain === 'bitcoin') {\n      const response = await axios.get(`https://api.blockcypher.com/v1/btc/main/addrs/${address}`, {\n        timeout: 10000,\n        headers: { 'User-Agent': 'Crypto-Guardian/1.0' },\n      })\n\n      const data = response.data\n      return {\n        address,\n        balance: data.balance?.toString() || '0',\n        transaction_count: data.n_tx || 0,\n        total_value: (parseFloat(data.total_received || '0') / 100000000).toString(),\n      }\n    } else if (blockchain === 'ethereum') {\n      const response = await axios.get(`https://api.blockcypher.com/v1/eth/main/addrs/${address}`, {\n        timeout: 10000,\n        headers: { 'User-Agent': 'Crypto-Guardian/1.0' },\n      })\n\n      const data = response.data\n      return {\n        address,\n        balance: data.balance?.toString() || '0',\n        transaction_count: data.n_tx || 0,\n        total_value: data.total_received || '0',\n      }\n    }\n\n    // Skip BlockCypher for other chains\n    return null\n  } catch (error) {\n    console.error(\n      'BlockCypher API error:',\n      error instanceof Error ? error.message : 'Unknown error'\n    )\n    return null\n  }\n}\n\n// 4. Simple local analysis (always available)\nexport const localAnalysis = (address: string, _blockchain: BlockchainType): AddressData => {\n  return {\n    address,\n    balance: '0',\n    transaction_count: 0,\n    total_value: '0',\n  }\n}\n\n// Main function that tries multiple APIs in order\nexport const getAddressData = async (\n  address: string,\n  blockchain: BlockchainType\n): Promise<AddressData> => {\n  // Try APIs in order of preference based on blockchain\n  const providers = [\n    () => blockchainInfoAPI(address, blockchain),\n    () => etherscanAPI(address, blockchain),\n    () => blockCypherAPI(address, blockchain),\n    () => Promise.resolve(localAnalysis(address, blockchain)),\n  ]\n\n  // For Ethereum chains, try Etherscan first\n  if (['ethereum', 'binance-smart-chain', 'polygon', 'arbitrum'].includes(blockchain)) {\n    providers.unshift(\n      () => etherscanAPI(address, blockchain),\n      () => blockCypherAPI(address, blockchain),\n      () => Promise.resolve(localAnalysis(address, blockchain))\n    )\n    providers.shift() // Remove blockchainInfoAPI\n  }\n\n  // For Bitcoin, try Blockchain.com first\n  if (blockchain === 'bitcoin') {\n    providers.unshift(\n      () => blockchainInfoAPI(address, blockchain),\n      () => blockCypherAPI(address, blockchain),\n      () => Promise.resolve(localAnalysis(address, blockchain))\n    )\n    providers.shift() // Remove etherscanAPI\n  }\n\n  // Try each provider until one succeeds\n  let result: AddressData | null = null\n  for (const provider of providers) {\n    try {\n      const providerResult = await provider()\n      if (\n        providerResult &&\n        (providerResult.balance !== undefined || providerResult.transaction_count !== undefined)\n      ) {\n        result = providerResult\n        break\n      }\n    } catch {\n      console.error('Provider failed, trying next...')\n    }\n  }\n\n  // If no provider succeeded, use fallback\n  if (!result) {\n    result = localAnalysis(address, blockchain)\n  }\n\n  // Calculate USD value if balance is available\n  if (result.balance) {\n    try {\n      const usdValue = await convertToUSD(result.balance, blockchain)\n      result.total_value = usdValue\n    } catch (error) {\n      console.error('Error calculating USD value:', error)\n      result.total_value = '0'\n    }\n  } else {\n    result.total_value = '0'\n  }\n\n  return result\n}\n","import axios from 'axios'\nimport NodeCache from 'node-cache'\nimport type { BlockchainType } from '../types'\n\n// Cache setup for prices (cache for 5 minutes)\nconst priceCache = new NodeCache({ stdTTL: 300 })\n\n// CoinGecko API configuration\nconst COINGECKO_BASE_URL = 'https://api.coingecko.com/api/v3'\n\n// Map blockchain types to CoinGecko IDs\nconst blockchainToCoinId: Record<BlockchainType, string> = {\n  ethereum: 'ethereum',\n  bitcoin: 'bitcoin',\n  'binance-smart-chain': 'binancecoin',\n  polygon: 'matic-network',\n  arbitrum: 'arbitrum',\n}\n\n// Get current price for a blockchain\nexport const getCurrentPrice = async (blockchain: BlockchainType): Promise<number> => {\n  const cacheKey = `price-${blockchain}`\n\n  // Check cache first\n  const cachedPrice = priceCache.get<number>(cacheKey)\n  if (cachedPrice) {\n    return cachedPrice\n  }\n\n  try {\n    const coinId = blockchainToCoinId[blockchain]\n\n    const response = await axios.get(`${COINGECKO_BASE_URL}/simple/price`, {\n      params: {\n        ids: coinId,\n        vs_currencies: 'usd',\n        include_24hr_change: false,\n      },\n      timeout: 10000,\n      headers: {\n        'User-Agent': 'Crypto-Guardian/1.0',\n        Accept: 'application/json',\n      },\n    })\n\n    const price = response.data[coinId]?.usd || 0\n\n    // Cache the price\n    priceCache.set(cacheKey, price)\n\n    return price\n  } catch (error) {\n    console.error('Error fetching price from CoinGecko:', {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      blockchain,\n    })\n\n    // Return 0 on error\n    return 0\n  }\n}\n\n// Convert balance to USD value\nexport const convertToUSD = async (\n  balance: string,\n  blockchain: BlockchainType\n): Promise<string> => {\n  try {\n    const price = await getCurrentPrice(blockchain)\n\n    // Convert balance from wei/satoshi to standard units\n    let standardBalance = '0'\n\n    if (blockchain === 'bitcoin') {\n      // Convert from satoshis (8 decimal places) to BTC\n      const satoshis = BigInt(balance) || 0n\n      standardBalance = (Number(satoshis) / 100000000).toString()\n    } else {\n      // Convert from wei (18 decimal places) to ETH/other EVM tokens\n      const wei = BigInt(balance) || 0n\n      standardBalance = (Number(wei) / 1e18).toString()\n    }\n\n    // Calculate USD value\n    const balanceInCrypto = parseFloat(standardBalance)\n    const usdValue = balanceInCrypto * price\n\n    // Return formatted USD value\n    return usdValue.toFixed(2)\n  } catch (error) {\n    console.error('Error converting to USD:', error)\n    return '0'\n  }\n}\n\n// Initialize with some popular prices\nexport const initializePriceCache = async () => {\n  const blockchains: BlockchainType[] = [\n    'ethereum',\n    'bitcoin',\n    'binance-smart-chain',\n    'polygon',\n    'arbitrum',\n  ]\n\n  // Pre-warm the cache with popular prices\n  const promises = blockchains.map(blockchain =>\n    getCurrentPrice(blockchain).catch(error =>\n      console.error(`Failed to fetch initial price for ${blockchain}:`, error)\n    )\n  )\n\n  await Promise.allSettled(promises)\n  console.log('Price cache initialized')\n}\n","import { Request, Response, NextFunction } from 'express'\nimport { setInterval } from 'timers'\n\n// Request rate limiter using in-memory store\nconst requestStore = new Map<string, { count: number; resetTime: number }>()\nconst RATE_LIMIT_WINDOW = 60000 // 1 minute in ms\nconst RATE_LIMIT_MAX_REQUESTS = 30 // 30 requests per minute per IP\n\nexport const rateLimiter = (req: Request, res: Response, next: NextFunction) => {\n  const clientIP =\n    req.ip || req.connection.remoteAddress || req.headers['x-forwarded-for'] || 'unknown'\n  const now = Date.now()\n\n  // Get or create client entry\n  let client = requestStore.get(clientIP as string)\n\n  if (!client || now > client.resetTime) {\n    // Reset or create new entry\n    client = {\n      count: 1,\n      resetTime: now + RATE_LIMIT_WINDOW,\n    }\n    requestStore.set(clientIP as string, client)\n    return next()\n  }\n\n  // Check rate limit\n  if (client.count >= RATE_LIMIT_MAX_REQUESTS) {\n    return res.status(429).json({\n      success: false,\n      error: 'Too many requests. Please try again later.',\n      code: 'RATE_LIMIT',\n      retryAfter: Math.ceil((client.resetTime - now) / 1000),\n    })\n  }\n\n  // Increment count\n  client.count++\n  next()\n}\n\n// Clean up old entries periodically\nsetInterval(() => {\n  const now = Date.now()\n  for (const [ip, client] of requestStore.entries()) {\n    if (now > client.resetTime) {\n      requestStore.delete(ip)\n    }\n  }\n}, 300000) // Clean every 5 minutes\n\n// CORS middleware\nexport const corsHeaders = (req: Request, res: Response, next: NextFunction) => {\n  // Set headers before any response\n  res.header('Access-Control-Allow-Origin', '*')\n  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')\n  res.header(\n    'Access-Control-Allow-Headers',\n    'Origin, X-Requested-With, Content-Type, Accept, Authorization'\n  )\n  res.header('Access-Control-Max-Age', '86400')\n\n  console.error(`CORS Request - Method: ${req.method}, Origin: ${req.headers.origin}`)\n\n  if (req.method === 'OPTIONS') {\n    console.error('CORS - Responding 200 to OPTIONS')\n    res.sendStatus(200)\n    return\n  }\n\n  next()\n}\n\n// Request validation middleware\nexport const validateRequest = (req: Request, res: Response, next: NextFunction) => {\n  // Check content type for POST requests\n  if (req.method === 'POST' && !req.headers['content-type']?.includes('application/json')) {\n    return res.status(400).json({\n      success: false,\n      error: 'Content-Type must be application/json',\n      code: 'INVALID_CONTENT_TYPE',\n    })\n  }\n\n  // Check request size\n  if (req.headers['content-length'] && parseInt(req.headers['content-length']) > 10240) {\n    // 10KB\n    return res.status(413).json({\n      success: false,\n      error: 'Request too large',\n      code: 'REQUEST_TOO_LARGE',\n    })\n  }\n\n  next()\n}\n\n// Security headers middleware\nexport const securityHeaders = (req: Request, res: Response, next: NextFunction) => {\n  res.setHeader('X-Content-Type-Options', 'nosniff')\n  res.setHeader('X-Frame-Options', 'DENY')\n  res.setHeader('X-XSS-Protection', '1; mode=block')\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin')\n  res.setHeader('Content-Security-Policy', \"default-src 'self'\")\n\n  next()\n}\n"],"mappings":"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","names":["NodeCache","axios","axios","NodeCache","localAnalysis"]}